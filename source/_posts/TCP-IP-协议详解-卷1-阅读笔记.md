---
title: TCP IP 协议详解 卷1 阅读笔记
date: 2012-08-05 09:25:34
tags:
- linux
---





TCP IP 协议详解 卷1--阅读笔记（原创）

（TCP IP illustrated）



由  王宇 原创并发布 ：



第1章概述



1.2分层






图1-1



1)链路层



2)网络层



3)运输层



4)应用层




图1-3



互联网的目的之一是在应用程序中隐藏所有的物理细节。



1.3 TCP/IP的分层




图1-4 TCP/IP协议族中不同层次的协议



TCP和UDP是运输层协议



TCP使用不可靠的IP服务，但它却提供一种可靠的运输层服务



UDP为应用程序发送和接收数据报



IP是网络层上的主要协议



ICMP是IP协议的附属协议



IGMP是Internet组管理协议



ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址



1.4互联网的地址



IP地址长32位




图1-5五类互联网地址




图1-6各类IP地址的范围



1.5域名系统



域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。



1.6封装



当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收入到的数据都要增加一些首部信息，该过程如图1-7所示：




图1-7



1.7分用



当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用



1.8客户-服务器模型



1.9端口号



TCP和UDP采用16位的端口号来识别应用程序



1.10标准化过程



Internet协会ISOC



Internet体系结构委员会IAB



Internet工程专门小组IETF



Internet研究专门小组IRIF



1.11RFC



所有关于Internet的正式标准都以RFC(RequestforComment)文档出版



1.12标准的简单服务



1.13互联网



1.14实现



1.15应用程序接口



1.16测试网络



第2章链路层



2.1引言



三个目的：



1）为IP模块发送和接收IP数据报



2）为ARP模块发送ARP请求和接收ARP应答



3）为RARP发送PARP请求和接收PARP应答



2.2以太网和IEEE802封装




图2-1IEEE802.2/802.3(RFC1024)和以太网的封装格式(RFC894)



  2.3尾部封装



  2.4 SLIP串行线路IP



  SerialLineIP是一种在串行线路上对IP数据报进行封装的简单形式，适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet



  SLIP协议定义的帧的格式：



  1）IP数据报以一个称作END(0xc0)的特殊字符结束，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符



  2）如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。



  3）如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它




  图2-2 SLIP报文的封装



  SLIP缺陷：



  1）每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端



  2）数据帧中没有类型字段



  3）SLIP没有在数据帧中加上检验和



  2.5压缩的SLIP



  CSLIP能把40个字节压缩到3-5个字节



  2.6 PPP点对点协议




  图：2-3PPP数据帧的格式



  优点：



  1）PPP支持在单根线路上运行多种协议，不只是IP协议



  2）每一帧都有循环冗余校验



  3）通信双方可以进行IP地址的动态协商



  4）与CSLIP类似，对TCP和IP报文首部进行压缩



  5）链路控制协议可以对多个数据链路选项进行设置



  2.7环回接口



  允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信，IP地址127.0.0.1分配给这个接口。



  2.8最大传输单元MTU



  以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492，这个特性：最大传输单元MTU



  如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每片都小于MTU



  2.9路径MTU



  两台通信主机路径中的最小MTU，它被称作路径MTU



  2.10串行线路吞吐量计算



  第3章IP网际协议



  3.1引言



  **所有的TCP、UDP、ICMP、及IGMP数据都以IP数据报格式传输



  **不可靠的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误，IP有一个简单的错误处理算法：丢弃数据报，然后发送ICMP消息报给信源端。



  **无连接的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。IP数据报可以不按发送顺序接收。



  3.2 IP首部




  **图3-1IP数据报格式及首部中的各字段



  目前的协议版本号是4，因此IP有时也称作IPv4



  首部长度指的是首部占32bit字的数目



  服务类型(TOS)，包括一个3bit的优先权子字段，4bitTOS，1bit保留必须为0




  图3-2服务类型字段推荐值



  总长度字段是指整个IP数据报的长度，以字节为单位。



  标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1,用于分片和重组



  TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间



  TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1.当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机



  首部检验和字段是根据IP首部计算的检验和码



  计算IP检验和，发送方首先把检验和字段置为0.然后，对首部中每个16bit进行二进制反码求和，结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1.如果结果不是全1，那么IP就丢弃收到的数据报。但不生成差错报文，由上层去发现丢失的数据报并进行重传。



  反码求和：



  例如：1100,1010，0000（校验位）



  求反：0011,0101



  求和：0011+0101=1000



  数据包：1100,1010,1000



  接收方收到数据后校验：0011+0101+0111=1111正确



  ICMP、IGMP、UDP和TCP都采用相同的检验和算法



  每一份IP数据报都包含源IP地址和目的IP地址



  最后一个字段是任选项



  3.3 IP路由选择



  如果目的主机与源主机直接相连或都在一个共享网络上，那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认路由器上，由路由器来转发该数据报。



  IP可以从TCP、UDP、ICMP和IGMP接收数据报并进行发送。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表收索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么（1）如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则（2）数据报被丢弃



  路由表中的信息：



  目的IP地址



  下一站路由器的IP地址



  标志



  为数据报的传输指定一个网络接口



  IP路由选择主要的功能：



  1）搜索路由表，寻找能与目的IP地址完全匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。



  2）搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。



  3）搜索路由表，寻找标为“默认”的表目



  如果上面这些步骤都没有成功，那么该数据报就不能被传送，一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。由ICMP负责发送。



  直接发送的例子：




  图3-3数据报从主机bsdi到sun的传送过程



  48bit的以太网地址是用ARP协议获得的




  图3-4从bsdi到ftp.uu.net的初始化路径



  关键点：



  1）例子中的所有主机和路由器都使用了默认路由



  2）数据报中的目的IP地址始终不发生任何变化



  3）每个链路层可能具有不同的数据帧首部，而且链路层得目的地址始终指的是下一站的链路层地址



  3.4子网寻址



IP地址分成：网络号(16bit)、子网号（8bit）、主机号(8bit)




  图3-5B类地址的一种子网编址



  3.5子网掩码




  图3-7两种不同的B类地址子网掩码的例子



  给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：（1）本子网上的主机；（2）本网络中其他子网中的主机；（3）其他网络上的主机



  3.6特殊情况的IP地址




  图3-9特殊情况的IP地址



  0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid、hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分



  3.7一个子网的例子



  3.8ifconfig命令



  TCP\IP对网络接口进行配置和查询的命令



  3.9 netstat命令



  netstat -in \\接口信息



  netstat -rn \\路由表



  route \\路由表



  第4章ARP地址解析协议



  4.1引言



  ARP为IP地址到对应的硬件地址之间提供动态映射。



  4.2一个例子




  图4-2当用户输入命令"ftp主机名"时ARP的操作



  1)把主机名转换成32bit的IP地址



  2)FTP客户端请求TCP用的到的IP地址建立连接



  3)TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报



  4)如果目的主机在本地网络上，那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报



  5)假定是一个以太网，那么发送端主机必须把32bit的IP地址变换成48bit的以太网地址。从逻辑internet地址到对应的物理硬件地址需要进行翻译，这就是ARP的功能



  6)ARP发送一份称为ARP请求的以太网数据帧给以太网上的每个主机。这个过程称为广播。ARP请求数据帧中包含目的主机的IP地址，其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址”



  7)目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP及对应的硬件地址



  8)收到ARP应答后，使ARP进行请求--应答交换的IP数据报现在就可以传送了



  9)发送IP数据报到目的主机



  点对点链路不使用ARP



  4.3 ARP高速缓存



  ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存，缓存中每一项的生存时间一般为20分钟



  查询命令：arp-a



  4.4 ARP的分组格式




  图：4-3用于以太网的ARP请求或应答分组格式



  以太网帧的类型：0x0806



  硬件类型字段表示硬件地址的类型



  操作字段指出四种操作类型：ARP请求：1；ARP应答：2；RARP请求：3；RARP应答4；



  4.5 ARP举例



  4.5.1一般的例子



  4.5.2对不存在主机的ARP请求



  4.5.3ARP高速缓存超时设置



  4.6 ARP代理



  如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理。



  arp-a后发现不同IP地址映射的硬件地址是相同的，这通常是使用委托ARP的线索



  4.7 免费ARP



  主机发送ARP查找自己的IP地址



  4.8 arp命令



  第5章RARP逆地址解析协议



  无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求，请求某个主机相应该无盘系统的IP地址。



  第6章ICMPInternet控制报文协议



  6.1引言



  ICMP传递差错报文以及其他需要注意的信息。一些ICMP报文把差错报文返回给用户进程。




  图：6-1ICMP封装在IP数据报内部




  图：6-2ICMP报文







  6.2 ICMP报文的类型




  图：6-3ICMP报文类型



  6.3 ICMP地址掩码请求与应答



  ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码



  6.4 ICMP时间戳请求与应答



  ICMP时间戳请求允许系统向另一个系统查询当前的时间



  6.4.1应答



  6.4.2另一种方法



  6.5 ICMP端口不可达差错（待续）



  6.6 ICMP报文的4.4BSD处理



  第7章Ping程序



  7.1引言



  7.2Ping程序



  7.3IP记录路由选项



  7.4IP时间戳选项







  第8章Traceroute程序



  8.1引言



  8.2Traceroute程序的操作



  8.3局域网输出



  8.4广域网输出



  8.5IP源站选路选项



  第9章IP选路



  9.1引言



  我们主要的目的是了解单个IP层如何做出路由决策




  图：9-1IP层工作流程



  9.2选路的原理



  IP搜索路由表的几个步骤：



  1）搜索匹配的主机地址：



  2）搜索匹配的网络地址：



  3）搜索默认表项



  9.2.1简单路由表



  netstat-rn




  图表



  五种不同的标志：



  U该路由可以使用



  G该路由是到一个网关（路由器）



  H该路由是到一个主机，也就是说，目的地址是一个完整的主机地址



  D该路由重定向报文创建的



  M该路由已被重定向报文修改



  9.2.2初始化路由表



  每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由



  route命令



  routeadddefaultsun1



  routeaddslipbsdi1



  一些系统允许在某个文件中指定默认的路由器，如：/etc/defaultrouter



  9.2.3较复杂的路由表



  9.2.4没有到达目的地的路由



  如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢？如果数据报是由本地主机产生的，那么就发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的错误报文。



  9.3 ICMP主机与网络不可达差错



  当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文



  9.4转发或不转发



  一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用



  9.5 ICMP重定向差错



  当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。




  图9-3ICMP重定向的例子



  重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表，一旦默认路由发生差错，默认路由器将通知它进行重定向



  9.5.1一个例子



  大多数的主机都把gateway指定为默认路由器



  9.5.2更多的细节



  9.6 ICMP路由器发现报文



  配置文件中指定静态路由，新的方法是利用ICMP路由器通告和请求报文,更新它们的路由表。一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。



  9.6.1路由器操作



  9.6.2主机操作



  9.6.3实现



  第10章动态选路协议



  10.1引言



  在网络很小，且与其他网络只有单个连接点且没有多余路由时，采用静态路由，上述三种情况不能全部满足，通常使用动态选路



  10.2动态选路



  10.3Unix选路守护程序



  10.4RIP：选路信息协议



  10.5RIP版本2



  10.6OSPF：开放最短路径优先



  10.7BGP：边界网关协议



  10.8CIDR：无类型域间选路



  第11章UDP用户数据报协议



  11.1引言




  图：11-1UDP封装



  UDP是一个简单的面向数据报的运输层协议



  UDP不提供可靠性



  应用程序必须关心IP数据报的长度，如果它超过网络的MTU，那么就要对IP数据报进行分片



  11.2 UDP首部




  图：11-2UDP首部



  11.3 UDP检验和



  UDP检验和覆盖UDP首部和UDP数据



  IP校验和指覆盖IP首部



  检验和的具体计算方法参见IP检验和部分



  如果发送端没有计算检验和而接收端检验到检验和有差错，那么UDP数据报就要被悄悄地丢弃，不产生任何差错报文。



  11.4一个简单的例子



  11.5 IP分片



  物理网络层一般要限制每次发送数据帧的最大长度。把一份IP数据报分片以后，只有到达目的地才进行重新分装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行重新组装，而不是在最终的目的地）



  回忆IP首部（图3-1），对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值，该值在数据报分片时被复制到每个片中，标志字段用其中一个比特来表示“更多的片”。除了最后一个片外，其他每个组成数据报的片都要把该片特置1.片偏移字段指的是该片偏移原始数据报开始处的位置



  当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立，有可能会失序。



  IP分片缺点：即使只丢失一片数据也要重传整个数据报，因为IP层本身没有超时重传的机制。TCP有超时和重传机制，UDP没有



  11.6ICMP不可达差错（需要分片）--待续



  11.7用traceroute确定路径MTU--待续



  11.8采用UDP的路径MTU发现--待续



  11.9UDP和ARP之间的交互作用--待续



  11.10最大UDP数据报长度--待续



  11.11ICMP源站抑制差错--待续



  11.12UDP服务器的设计



  11.12.1客户IP地址及端口号



  IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端得UDP端口号。当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，这个特性允许一个交互UDP服务器对多个客户进行处理。



  11.12.2目标IP地址



  一些应用程序需要知道数据报是发送给谁的，即目的IP地址。不是所有的实现都提供这个功能。



  11.12.3 UDP输入队列



  通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序



  排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的



  11.12.4限制本地IP地址



  大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符的特点。这就表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。



  本地以*.7777格式打印，星号表示任何本地IP地址。可以限制为：140,252,1,29.777



  11.12.5限制远端IP地址



  11.12.6每个端口有多个接收者



  大多数的系统在某一时刻只允许一个程序端点与某个本地IP



  第12章广播和多播



  12.1引言



  三种IP地址：单播地址、广播地址、和多播地址



  广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机内的两进程间存在一条连接



  单播：以太网帧仅发往单个目的主机



  广播：主机要向网上的所有其他主机发送帧



  多播：处于单播和广播之间：帧仅发送给属于多播组的多个主机，减少了对应用不感兴趣主机的处理负荷，详见下图：




  图：12-1协议栈各层对收到帧的过滤过程



  12.2广播



  12.2.1受限的广播



  受限的广播地址：255.255.255.255



  12.2.2指向网络的广播



  指向网络的广播地址是主机号为全1的地址，例如A类网络广播:netid.255.255.255(netid为A类网络号)



  12.2.3指向子网的广播



  指向子网的广播地址为主机号为全1且有特定子网号的地址：128.1.2.255



  12.2.4指向所有子网的广播



  指向所有子网的广播地址的子网号及主机号为全1。例如：子网掩码：255.255.255.0IP：128.1.255.255



  12.3广播的例子



  12.4多播



  12.4.1多播组地址



  12.4.2多播组地址到以太网地址的转换



  12.4.3FDDI和令牌环网络中的多播



  第13章IGMPInternet组管理协议



  13.1引言



  IGMP让一个物理网络上的所有系统知道主机当前所在的多播组




  图：13-1IGMP报文封装在IP数据报中



  13.2 IGMP报文




  图：13-2IGMP报文的字段格式



  13.3 IGMP协议



  13.3.1 加入一个多播组



  多播的基础就是一个进程概念。在一个给定接口上的多播组中的成员是动态的--它随时因进程加入和离开多播组而变化



  13.3.2 IGMP报告和查询



  1）当第一个进程加入一个组时，主机就发送一个IGMP报告



  2）进程离开一个组时，主机不发送IGMP报告



  3）多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程



  4）主机通过发送IGMP报告来响应一个IGMP查询，对每个至少包含一个进程的组均要发回IGMP报告



  13.3.3实现细节



  13.3.4生存时间字段



  13.3.5所有主机组



  13.4一个例子







  第14章DNS域名系统（待续）



  14.1引言



  14.2DNS基础



  14.3DNS的报文格式



  14.3.1DNS查询报文中的问题部分



  14.3.2DNS响应报文中的资源记录部分



  14.4一个简单的例子



  14.5指针查询



  14.6资源记录



  14.7高速缓存



  14.8用UDP还是TCP



  14.9另一个例子



  第15章TFTP简单文件传送协议（待续）



  第16章BOOTP引导程序协议（待续）



  第17章TCP传输控制协议



  17.1引言



  17.2TCP的服务



  TCP提供一种面向连接的、可靠的字节流服务



  广播和多播不能用于TCP



  TCP通过下列方式来提供可靠性：



  应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位称为报文段或段



  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确定，将重发这个报文段



  当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒



  TCP将保持它首部和数据的检验和。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段



  既然TCP报文段为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。



  既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据



  TCP还能提供流量控制



  17.3 TCP的首部




  图：17-1TCP数据在IP数据报中的封装




  图：17-2TCP包首部



  每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程



  序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达2^32-1后又从0开始



  当建立一个新的连接时，SYN标志变1



  只有ACK标志为1时确认序号字段才有效



  TCP可以表述为一个没有选择确认或否认的滑动窗口协议



  首部长度给出首部中32bit字的数目



  在TCP首部中有6个标志比特，它们中的多个可同时被设置为1



  URG、ACK、PSH、RST、SYN、FIN



  TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节



  检验和覆盖了整个的TCP报文段，一定是由发端计算和存储，并由收端进行验证



  紧急指针时一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式



最常见的可选字段是最长报文大小，又称为MSS(MaximumSegmentSize)







  第18章TCP连接的建立与终止



  18.1引言



  TCP是一个面向连接的协议



  18.2连接的建立与终止



  18.2.1tcpdump的输出




  图：18-1TCP连接建立与终止的tcpdump输出显示



  第1行中，字段1415531521:1415531521(0)表示分组的序号是1415531521,而报文段中数据字节数为0.tcpdump显示这个字段的格式是开始的序号、一个冒号、隐含的结尾序号及圆括号内的数据字节数



  第2行中，字段ack1415531522表示确认序号



  每行显示的字段win4096表示发端通告的窗口大小



  最后一个字段<mss1024>表示由发端指明的最大报文段长度选项



  18.2.2时间系列



  18.2.3建立连接协议




  图：18-3连接建立与终止的时间系列



  1)请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始化序号，报文段1



  2)服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号



  3)客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）



  发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一个端执行被动打开



  18.2.4连接终止协议



  建立一个连接需要三次握手，而终止一个连接要经过4次握手



  18.2.5正常的tcpdump输出



  18.3连接建立的超时



  大多数伯克利系统将建立一个新连接的最长时间限制为75秒



  18.3.1第一次超时时间



  BSD版得TCP软件采用一种500ms的定时器



  18.3.2服务类型字段



  18.4最大报文段长度



  最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度



  在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536



  18.5 TCP的半关闭



  TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是所谓的半关闭



  为什么要有半关闭？一个例子是Unix中的rsh(1)命令，它将完成在另一个系统上执行一个命令



  18.6 TCP的状态变迁图




  图：18-12TCP的状态变迁图



  图中要注意的第一点是一个状态变迁的子集是“典型的”。我们用粗的实线箭头表示正常的客户端状态变迁，用粗的虚线箭头表示正常的服务器状态变迁



  第二点是两个导致进入ESTABLISHED状态的变迁对应打开一个连接，而两个导致从ESTABLISHED状态离开的变迁对应关闭一个连接



  18.6.1 2MSL等状态



  TIME_WAIT状态也称为2MSL等待状态



  18.6.2平静时间的概念



  18.6.3 FIN_WAIT_2状态



  18.7复位报文段



  我们已经介绍了TCP首部中的RST比特是用于“复位”的。一般来说，无论何时一个报文段发往基准的连接出现错误，TCP都会发出一个复位报文段



  18.7.1到不存在的端口的连接请求



  产生复位的一种常见情况是当连接请求到达时，目的端口没有进行正在听，UPD产生一个ICMP端口不可达到的信息，而TCP则使用复位。



  18.7.2异常终止一个连接



  终止一个连接的正常方式是一方发送FIN。有时这也称为有序释放



  但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。有时称为异常释放



  ^D产生一个RST，收到RST的一方将终止该连接，并通知应用层连接复位



  18.7.3检测半打开连接



  如果一方已经关闭或异常终止连接而另一方却不知道，我们将这种的TCP连接称为半打开的



  任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常



  TCP的处理原则是接收方以复位作为应答







  18.8同时打开



  两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小



  18.9同时关闭



  18.10 TCP选项



  18.11 TCP服务器的设计



  大多数的TCP服务器进程是并发的。当一个新的连接请求到达服务器时，服务器接受这个请求，并调用一个新进程来处理这个新的客户请求



  18.11.1TCP服务器端口号



  18.11.2限定的本地IP地址



  18.11.3限定的远端IP地址



  18.11.4呼入连接请求队列



  规则：



  1）正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受，但还没有被应用层所接受。注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出



  2）应用层将指明该队列的最大长度，这个值通常称为积压值(blacklog).



  3）当一个连接请求（即SYN）到达时，TCP使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。



  4）如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立



  5）如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN



  第19章TCP的交互数据流



  19.1引言



  19.2交互式输入



  Rlogin连接键入一个交互命令时所产生的数据流



  通常每一个交换按键都会产生一个数据分组，也就是说，每次从客户传到服务器的是一个字节按键。而且，Rlogin需要远程回显我们键入的字符,这样就会产生4个报文段：




  图19-1一种可能的处理远程交互按键回显的方法



  1）来自客户的交互按键



  2）来自服务器的按键确认



  3）来自服务器的按键回显



  4）来自客户的按键回显确认



  19.3经受时延的确认



  19.4Nagle算法



  算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组



  算法的优越之处在于它是自适应的：确认到达的越快，数据也就发送得越快



  19.4.1关闭Nagle算法



  有时我们也需要关闭Nagle算法。一个典型的例子是X窗口系统服务器



  19.4.2一个例子



  19.5窗口大小通告







  第20章TCP的成块数据流



  20.1引言



  滑动窗口协议是一种流量控制方法



  由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输



  20.2正常数据流




  图：20-1从svr4传输8192个字节到bsdi



  报文段7的ACK的序号是2048，不是3073.原因详见p209



  报文段11-16说明了通常使用的“隔一个报文段确认”的策略



  注意到报文段7、14和16中的ACK确认了两个收到的报文段是很重要的。使用TCP的滑动窗口协议时，接收方不必确认每个收到的分组



  20.3滑动窗口



  针对一个报文的大小。




  图：20-4TCP滑动窗口的可视化表示



  1)称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。



  2)当窗口右边向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时



  3)当右边沿向左移动时，我们称之为窗口收缩。不推荐使用



  一个例子（详见P213）



  20.4窗口大小



  20.5PUSH标志



  发送方使用该标志通知接收方将所收到的数据全部提交给接收进程



  目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志



  20.6慢启动



  针对一组报文的多少



  慢启动算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作



  慢启动为发送方的TCP增加了另一个窗口：拥塞窗口记为cwnd



  超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的



  20.7成块数据的吞吐量




  图：20-9时间0-15的成块数据吞吐量举例




  图：20-10时间16-31的成块数据吞吐量举例



具体解释详见(P218-P219)



  时间7，一个8个时间单元的往返时间RTT



  时间31，是连接的理想稳定状态



  20.7.1带宽时延乘积？



  20.7.2拥塞



  当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞



  20.8紧急方式



  一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中



  第21章TCP的超时与重传



  21.1引言



  TCP提供可靠的运输层方法之一就是确定从另一端收到的数据。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时，还没有收到确认，它就重传该数据，关键之处就在于超时和重传的策略，即怎么决定超时间隔和如何确定重传的频率。



  TCP管理4个不同的定时器



  1)重传定时器



  2)坚持定时器，使窗口大小信息保持不断流动



  3)保活定时器，可检测到一个空闲连接的另一端何时崩溃或重启



  4)2MSL定时器测量一个连接处于TIME_WAIT状态的时间



  21.2超时与重传的简单例子




  图：21-1TCP超时和重传的简单例子



  21.3往返时间测量



  TCP超时与重传中最重要的部分就是对一个给定连接的往返时间（RTT）的测量，TCP应该跟踪这些变化并相应地改变其超时时间



  21.4往返时间RTT的例子



  检查TCP的超时和重传、慢启动以及拥塞避免等实现细节



  21.4.1往返时间RTT的测量



  21.4.2RTT估计器的计算



  21.4.3慢启动



  21.5拥塞举例



  图：21-710秒标记处附近重传的分组交换







  21.6拥塞避免算法



  拥塞避免算法是一种处理丢失分组（详见上节）的方法



  拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点，在实际中这两个算法通常在一起实现



  拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh



  算法的工作过程(p235)，没有看懂，其他资料：以下引自《网络拥塞控制（三）》





  慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：



  开始 ---> cwnd = 1



  经过1个RTT后 ---> cwnd = 2*1 = 2



  经过2个RTT后 ---> cwnd = 2*2= 4



  经过3个RTT后 ---> cwnd = 4*2 = 8



  如果带宽为W，那么经过RTT*log 2 W时间就可以占满带宽。





  拥塞避免：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。



  上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？



  首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：



  1. 把ssthresh降低为cwnd值的一半



  2. 把cwnd重新设置为1



  3. 重新进入慢启动过程。



  从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。



  其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：



  1. 把ssthresh设置为cwnd的一半



2. 把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)



  3. 重新进入拥塞避免阶段。





  后来的“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。



  具体来说快速恢复的主要步骤是：



  1. 当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。



  2. 再收到重复的ACK时，拥塞窗口增加1。



  3. 当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。





  21.7快速重传与快速恢复算法



  21.8拥塞举例（续）



  21.9按每条路由进行度量



  21.10 ICMP的差错



  21.11重新分组



  第22章TCP的坚持定时器



  22.1引言



  TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方便用一个坚持定时器来周期性地间接收方查询，以便发现窗口是否已增大。这些发送方发出的报文段称为窗口探查



  22.2一个例子



  22.3糊涂窗口综合症



  第23章TCP的保活定时器



  23.1引言



  如果连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。



  许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动，许多实现提供的保活定时器可以提供这种能力。



  保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以代表客户使用资源



  23.2描述



  若干时间内没有任何动作，则服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一



  1、客户主机依然正常运行，并从服务器可达



  2、客户主机已经崩溃，并且关闭或者正在重新启动



  3、客户主机崩溃已经重新启动



  4、客户主机正常运行，但是从服务器不可达



  23.3保活举例



  23.3.1另一端崩溃



  23.3.2另一端崩溃并重新启动



  23.3.3另一端不可达



  第24章TCP的未来和性能



  第25章SNMP简单网络管理协议



  第26章Telnet和Rlogin远程登录



  第27章FTP文件传送协议



  第28章SMTP简单邮件传送协议



  第29章网络文件系统



  第30章其他的TCP/IP应用程序










